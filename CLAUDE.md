# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

pyjevsim is a DEVS (Discrete Event System Specification) simulation framework with journaling functionality. It provides snapshot and restore capabilities for models and simulation engines. Compatible with Python 3.10+.

## Key Dependencies

- **dill ~= 0.3.6**: Required for model serialization and restoration
- **pytest**: Optional, for running tests and examples

Install all dependencies: `pip install -r requirements.txt`

## Common Commands

### Testing
```bash
pytest tests/                              # Run all tests
pytest tests/test_behavioral_model.py      # Run specific test file
```

### Running Examples
```bash
python examples/banksim/banksim.py         # Basic bank simulation
python examples/banksim/banksim_snapshot.py # Bank simulation with snapshot
python examples/banksim/banksim_restore.py  # Restore from snapshot
```

## Architecture

### Core Execution Model

The framework follows DEVS (Discrete Event System Specification) formalism:

1. **SysExecutor** (`system_executor.py`): The simulation engine that manages time advancement, event scheduling, and model execution
   - Uses a priority queue (`ScheduleQueue`) for event scheduling
   - Manages global simulation time and model lifecycle (creation/destruction)
   - Handles message routing between models via port coupling
   - Supports both virtual time (`V_TIME`) and real-time (`R_TIME`) execution

2. **Model Types**:
   - **BehaviorModel** (`behavior_model.py`): Atomic models with state machines
     - Implements `ext_trans()` (external transition), `int_trans()` (internal transition), `output()`
     - State-based with configurable deadlines
   - **StructuralModel** (`structural_model.py`): Coupled models containing sub-models
     - Aggregates multiple models
     - Manages internal coupling between sub-models

3. **Executor Pattern**:
   - Models are wrapped by executors (`BehaviorExecutor`, `StructuralExecutor`)
   - ExecutorFactory creates appropriate executor types
   - Executors manage timing, transitions, and message delivery

### Message Handling

- **SysMessage** (`system_message.py`): Message objects passed between models
- **MessageDeliverer**: Batches and delivers messages
- Port-based coupling: Models communicate via named input/output ports
- `port_map` dictionary: Maps `(source_model, output_port)` to list of `(dest_model, input_port)`

### Snapshot/Restore System

- **SnapshotManager** (`snapshot_manager.py`): Coordinates snapshot operations
- **SnapshotExecutor**: Wraps executors to enable state capture
- Uses `dill` for deep serialization of model state
- Can snapshot entire simulation state or individual models
- Restore reconstructs simulation from serialized state

### Event Scheduling

- **ScheduleQueue** (`schedule_queue.py`): Priority queue for executor scheduling
- Based on requested execution time (`req_time`)
- Executors report next event time via `time_advance()`
- Schedule loop: pop executor → output → internal transition → reschedule

### Key Data Structures

- `waiting_obj_map`: Models waiting to be instantiated (keyed by creation time)
- `active_obj_map`: Currently active model executors (keyed by object ID)
- `port_map`: Coupling relations between models
- `model_map`: Name-to-executor lookup
- `input_event_queue`: External events injected into simulation
- `output_event_queue`: Events generated by simulation

## Development Notes

- Model execution follows strict DEVS semantics: output → transition → reschedule
- Thread safety provided via locks for external event insertion
- Infinite time constant represents "no scheduled event"
- DefaultMessageCatcher handles uncoupled ports
- Examples in `examples/` demonstrate behavioral, structural, and snapshot patterns
